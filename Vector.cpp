#include "Vector.h"

// FIXME:今回は2Dゲームのため上ベクトルは[Y:-1]とする
// 
// 定数の初期化
const Vector3 Vector3::ZeroVector(0.0f, 0.0f, 0.0f);
const Vector3 Vector3::UpVector(0.0f, -1.0f, 0.0f);
const Vector3 Vector3::DownVector(0.0f, 1.0f, 0.0f);
const Vector3 Vector3::LeftVector(-1.0f, 0.0f, 0.0f);
const Vector3 Vector3::RightVector(1.0f, 0.0f, 0.0f);


//--------------------------------//
//	引数つきコンストラクタ
//	引数	：初期化する要素
//	役割	：ベクトルをそれぞれの引数で初期化する
//--------------------------------//
Vector3::Vector3(float aug_x, float aug_y, float aug_z)
{
    x = aug_x;
    y = aug_y;
    z = aug_z;
}

//--------------------------------//
//	引数つきコンストラクタ
//	引数	：初期化する要素
//	役割	：ベクトルを一つ引数で初期化する
//--------------------------------//
Vector3::Vector3(float v)
{
    x = v;
    y = v;
    z = v;
}

//--------------------------------//
//	関数名	：Set
//	引数	：セットする値
//	戻り値	：なし
//	役割	：渡された値をセットする
//--------------------------------//
void Vector3::Set(float aug_x, float aug_y, float aug_z)
{
    x = aug_x;	y = aug_y; z = aug_z;
}


//--------------------------------//
//	関数名	：Length
//	引数	：なし
//	戻り値	：求めた長さ
//	役割	：自分自身のベクトルの長さを求めて返す
//--------------------------------//
float Vector3::Length()
{
    return ((float)sqrt((x * x) + (y * y) + (z * z)));
}


//--------------------------------//
//	関数名	：Normalize
//	引数	：なし
//	戻り値	：正規化したベクトル
//	役割	：自分自身を正規化したものを返す
//--------------------------------//
Vector3 Vector3::Normalize()
{
    if (Length())
        return Vector3(x / Length(), y / Length(), z / Length());
    return Vector3(0, 0, 0);
}

//--------------------------------//
//	関数名	：Print
//	引数	：なし
//	戻り値	：なし
//	役割	：自分自身をコンソールに表示する
//--------------------------------//
void Vector3::Print()
{
    printf("x:%f y:%f z:%f\n", x, y, z);
}

//--------------------------------//
//	オーバーロードした演算子：=
//	引数	：代入するベクトルと代入されるベクトル
//	戻り値	：引数
//	役割	：引数のベクトルを自分に代入する
//--------------------------------//
Vector3& Vector3::operator = (const Vector3& a)
{
    x = a.x;
    y = a.y;
    z = a.z;
    return *this;
}


//--------------------------------//
//	オーバーロードした演算子：==
//	引数	：比較するベクトル二つ
//	戻り値	：ほぼ同じかどうか
//	役割	：二つのベクトルをほぼ同じかどうか調べて返す
//--------------------------------//
bool operator == (Vector3& a, Vector3& b)
{
    Vector3 ans = a - b;
    if (ans.x < 0.0001f && ans.x > -0.0001f &&
        ans.y < 0.0001f && ans.y > -0.0001f &&
        ans.z < 0.0001f && ans.z > -0.0001f)
        return true;
    else
        return false;
}

//--------------------------------//
//	オーバーロードした演算子：+
//	引数	：足し算するベクトル二つ
//	戻り値	：足した結果
//	役割	：ベクトルどうしを足し算して返す
//--------------------------------//
Vector3 operator + (Vector3& a, Vector3& b)
{
    return Vector3(a.x + b.x, a.y + b.y, a.z + b.z);
}
//--------------------------------//
//	オーバーロードした演算子：+=
//	引数	：足し算するベクトル
//	戻り値	：足した結果の自分
//	役割	：引数を自分に足す
//--------------------------------//
Vector3& Vector3::operator += (const Vector3& a)
{
    x += a.x;
    y += a.y;
    z += a.z;
    return *this;
}


//--------------------------------//
//	オーバーロードした演算子：-
//	引数	：引き算するベクトル二つ
//	戻り値	：引いた結果
//	役割	：ベクトルどうしを引き算して返す
//--------------------------------//
Vector3 operator - (Vector3& a, Vector3& b)
{
    return Vector3(a.x - b.x, a.y - b.y, a.z - b.z);
}
//--------------------------------//
//	オーバーロードした演算子：-=
//	引数	：引き算するベクトル
//	戻り値	：引いた結果の自分
//	役割	：引数を自分に引く
//--------------------------------//
Vector3& Vector3::operator -= (const Vector3& a)
{
    x -= a.x;
    y -= a.y;
    z -= a.z;
    return *this;
}


//--------------------------------//
//	オーバーロードした演算子：*
//	引数	：内積を計算するベクトル二つ
//	戻り値	：計算した結果のスカラー
//	役割	：二つのベクトルの内積を返す
//--------------------------------//
float operator * (Vector3& a, Vector3& b)
{
    return ((a.x * b.x) + (a.y * b.y) + (a.z * b.z));
}


//--------------------------------//
//	オーバーロードした演算子：*
//	引数	：スカラー倍するベクトルと任意の数
//	戻り値	：スカラー倍したベクトル
//	役割	：ベクトルを引数分スカラー倍して返す
//--------------------------------//
Vector3 operator * (Vector3& a, float n)
{
    return Vector3(a.x * n, a.y * n, a.z * n);
}
Vector3 operator * (float n, Vector3& a)
{
    return Vector3(a.x * n, a.y * n, a.z * n);
}
//--------------------------------//
//	オーバーロードした演算子：*=
//	引数	：かけ算するスカラー
//	戻り値	：かけた結果の自分
//	役割	：引数を自分にかける
//--------------------------------//
Vector3& Vector3::operator *= (const float n)
{
    x *= n;
    y *= n;
    z *= n;
    return *this;
}


//--------------------------------//
//	オーバーロードした演算子：/
//	引数	：スカラー除算するベクトルと任意の数
//	戻り値	：スカラー除算したベクトル
//	役割	：ベクトルを引数分スカラー除算して返す
//--------------------------------//
Vector3 operator / (Vector3& a, float n)
{
    if (n != 0)
        return Vector3(a.x / n, a.y / n, a.z / n);
    else
    {
        return Vector3(0, 0, 0);
        puts("ベクトルクラス内でゼロ除算発生");
    }
}
Vector3 operator / (float n, Vector3& a)
{
    if (n != 0)
        return Vector3(a.x / n, a.y / n, a.z / n);
    else
    {
        return Vector3(0, 0, 0);
        puts("ベクトルクラス内でゼロ除算発生");
    }
}
//--------------------------------//
//	オーバーロードした演算子：/=
//	引数	：除算するスカラー
//	戻り値	：除算した結果の自分
//	役割	：引数で自分を除算する
//--------------------------------//
Vector3& Vector3::operator /= (const float n)
{
    if (n != 0)
    {
        x /= n;
        y /= n;
        z /= n;
        return *this;
    }
    else
    {
        (*this) = Vector3(0, 0, 0);
        return *this;
        puts("ベクトルクラス内でゼロ除算発生");
    }
}

//--------------------------------//
//	オーバーロードした演算子：%
//	引数	：外積を求めるベクトル二つ
//	戻り値	：計算したベクトル
//	役割	：二つのベクトルの外積を計算して返す
//--------------------------------//
Vector3 operator % (Vector3& a, Vector3& b)
{
    return Vector3((a.y * b.z - a.z * b.y), (a.z * b.x - a.x * b.z), (a.x * b.y - a.y * b.x));

}
//--------------------------------//
//	オーバーロードした演算子：%=
//	引数	：外積を計算するベクトル
//	戻り値	：計算した結果の自分
//	役割	：外積の結果を自分に代入する
//--------------------------------//
Vector3& Vector3::operator %= (const Vector3& a)
{
    Vector3 temp;
    temp.x = ((y * a.z) - (z * a.y));
    temp.y = ((z * a.x) - (x * a.z));
    temp.z = ((x * a.y) - (y * a.x));

    x = temp.x;
    y = temp.y;
    z = temp.z;

    return *this;
}
